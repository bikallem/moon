//! Constructs the build plan from the given build conditions.
//!
//! This module handles a different thing from the package dependency graph
//! generated by [`crate::solve`]. `solve` mainly constructs a dependency graph
//! that is not affected by what we're actually building, nor does it cares
//! about what actions are actually carried out on the dependency graph (like
//! check, build or test).
//!
//! In contrast, this module generates the actual build plan from a list of
//! input action nodes. Irrelevant packages are not included in this graph,
//! nor does irrelevant actions.
//!
//! The result of this module is analogous to Rust Cargo's [Compile unit graph][cu].
//!
//! [cu]: https://github.com/rust-lang/cargo/blob/master/src/cargo/core/compiler/unit.rs

use std::{collections::HashMap, path::PathBuf};

use indexmap::{set::MutableValues, IndexSet};
use moonutil::{
    common::TargetBackend,
    cond_expr::{OptLevel, ParseCondExprError},
};
use petgraph::{
    csr::DefaultIx,
    graph::{DiGraph, NodeIndex},
    visit::DfsPostOrder,
};

use crate::{
    cond_comp::{self, CompileCondition},
    discover::DiscoverResult,
    model::{BuildTarget, TargetAction, TargetKind},
    solve::DepRelationship,
};

#[derive(Clone, Copy, PartialEq, PartialOrd, Ord, Eq, Hash)]
pub struct BuildNodeId(NodeIndex<DefaultIx>);

type BuildActionGraph = DiGraph<BuildActionSpec, ()>;

/// A directed graph representation of build dependencies and targets.
///
/// `AbstractBuildGraph` maintains a directed graph where nodes represent build
/// components and edges represent dependencies between them. It also stores
/// specifications for each build target, mapping targets to their detailed
/// configuration and requirements.
#[derive(Default)]
pub struct BuildPlan {
    graph: BuildActionGraph,
    target_map: HashMap<BuildPlanNode, BuildNodeId>,
}

impl BuildPlan {
    pub fn get_id_from_node(&self, node: BuildPlanNode) -> Option<BuildNodeId> {
        self.target_map.get(&node).copied()
    }
}

/// A node in the build dependency graph, containing a build target and the
/// corresponding action that should be performed on that target.
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub struct BuildPlanNode {
    pub target: BuildTarget,
    pub action: TargetAction,
}

/// The specification of the specific build target, e.g. its files.
pub enum BuildActionSpec {
    Check(Vec<PathBuf>),
    /// Build the given list of MoonBit source files.
    BuildMbt(Vec<PathBuf>),
    /// Build the given list of C source files.
    BuildC(Vec<PathBuf>),
    /// Link the core files from the given list of targets, **in order**.
    LinkCore(Vec<BuildTarget>),
    /// Make executable; link with the C artifacts of the given list of targets,
    /// if any.
    MakeExecutable(Vec<BuildTarget>),
    GenerateMbti,

    /// A placeholder for pending nodes that are not yet resolved.
    #[doc(hidden)]
    Pending,
}

/// Represents the environment in which the build is being performed.
pub struct BuildEnvironment {
    // FIXME: Target backend should go into the solver, not here
    target_backend: TargetBackend,
    opt_level: OptLevel,
    // Can have more, e.g. cross compile
}

/// Represents errors that may occur during build graph construction.
///
/// TODO: Will we even meet errors during build graph construction?
#[derive(Debug, thiserror::Error)]
pub enum BuildPlanConstructError {
    // TODO: This parsing should be moved earlier into the pipeline
    #[error("Error when parsing conditional compilation expression of {node:?}: {err}")]
    ParseCondExprError {
        node: BuildPlanNode,
        err: ParseCondExprError,
    },
}

/// Construct an abstract build graph from the given packages and input actions.
pub fn build_plan(
    packages: &DiscoverResult,
    build_deps: &DepRelationship,
    build_env: &BuildEnvironment,
    input: &[BuildPlanNode],
) -> Result<BuildPlan, BuildPlanConstructError> {
    let mut constructor = BuildPlanConstructor::new(packages, build_deps, build_env);
    constructor.build(input)?;
    Ok(constructor.finish())
}

/// The struct responsible for holding the states and dependencies used during
/// the construction of a build plan.
struct BuildPlanConstructor<'a> {
    // Input environment
    packages: &'a DiscoverResult,
    build_deps: &'a DepRelationship,
    build_env: &'a BuildEnvironment,

    /// The resulting build plan
    res: BuildPlan,

    /// Currently pending nodes that need to be processed.
    pending: Vec<BuildPlanNode>,
}

impl<'a> BuildPlanConstructor<'a> {
    fn new(
        packages: &'a DiscoverResult,
        build_deps: &'a DepRelationship,
        build_env: &'a BuildEnvironment,
    ) -> Self {
        Self {
            packages,
            build_deps,
            build_env,
            res: BuildPlan::default(),
            pending: Vec::new(),
        }
    }

    fn finish(self) -> BuildPlan {
        self.res
    }

    fn build(&mut self, input: &[BuildPlanNode]) -> Result<(), BuildPlanConstructError> {
        assert!(
            self.pending.is_empty(),
            "Pending nodes should be empty before starting the build"
        );
        self.pending.extend_from_slice(input);
        while let Some(node) = self.pending.pop() {
            // check if the node is already resolved
            if let Some(node_id) = self.res.target_map.get(&node) {
                if !matches!(self.res.graph[node_id.0], BuildActionSpec::Pending) {
                    // Already resolved, skip
                    continue;
                }
            }

            self.build_action_dependencies(node)?;
        }
        Ok(())
    }

    /// Tell the build graph that we need to calculate the graph portion of a
    /// new node. To deduplicate pending nodes, this should be called before
    /// adding relevant edges to the graph (since the latter will also add the
    /// node into the graph).
    fn need_node(&mut self, node: BuildPlanNode) -> BuildNodeId {
        if let Some(node_id) = self.res.target_map.get(&node) {
            *node_id
        } else {
            self.pending.push(node);
            let node_id = self.res.graph.add_node(BuildActionSpec::Pending);
            self.res.target_map.insert(node, BuildNodeId(node_id));
            BuildNodeId(node_id)
        }
    }

    /// Tell the build graph that the given node has been resolved into a
    /// concrete action specification.
    fn resolved_node(&mut self, node_id: BuildNodeId, spec: BuildActionSpec) {
        self.res.graph[node_id.0] = spec;
    }

    fn add_edge(&mut self, start: BuildNodeId, end: BuildNodeId) {
        self.res.graph.add_edge(start.0, end.0, ());
    }

    /// Calculate the build action's dependencies and insert relevant edges to the
    /// build action graph.
    fn build_action_dependencies(
        &mut self,
        node: BuildPlanNode,
    ) -> Result<(), BuildPlanConstructError> {
        match node.action {
            TargetAction::Check => self.build_check(node),
            TargetAction::Build => self.build_build(node),
            TargetAction::BuildCStubs => self.build_build_c_stubs(node),
            TargetAction::LinkCore => {
                panic!(
                    "Link core should not appear in the wild without \
                    accompanied by MakeExecutable. Anytime it is met in the \
                    pending list, it should be already resolved."
                )
            }
            TargetAction::MakeExecutable => self.build_make_exec_link_core(node),
        }
    }

    fn build_check(&mut self, node: BuildPlanNode) -> Result<(), BuildPlanConstructError> {
        // Check depends on `.mi` of all dependencies, which practically
        // means the Check of all dependencies.
        let self_id = self.need_node(node);
        for dep in self
            .build_deps
            .dep_graph
            .neighbors_directed(node.target, petgraph::Direction::Incoming)
        {
            let dep_node = BuildPlanNode {
                target: dep,
                action: TargetAction::Check,
            };
            let dep_node = self.need_node(dep_node);
            self.add_edge(self_id, dep_node);
        }

        // Resolve the source files
        let source_files = self.resolve_mbt_files_for_node(node)?;
        self.resolved_node(self_id, BuildActionSpec::Check(source_files));

        Ok(())
    }

    fn build_build(&mut self, node: BuildPlanNode) -> Result<(), BuildPlanConstructError> {
        // Build depends on `.mi`` of all dependencies. Although Check can
        // also emit `.mi` files, since we're building, this action actually
        // means we need to build all dependencies.
        let self_id = self.need_node(node);
        for dep in self
            .build_deps
            .dep_graph
            .neighbors_directed(node.target, petgraph::Direction::Incoming)
        {
            let dep_node = BuildPlanNode {
                target: dep,
                action: TargetAction::Build,
            };
            let dep_node = self.need_node(dep_node);
            self.add_edge(self_id, dep_node);
        }

        // Resolve the source files
        let source_files = self.resolve_mbt_files_for_node(node)?;
        self.resolved_node(self_id, BuildActionSpec::BuildMbt(source_files));

        Ok(())
    }

    fn resolve_mbt_files_for_node(
        &mut self,
        node: BuildPlanNode,
    ) -> Result<Vec<PathBuf>, BuildPlanConstructError> {
        let pkg = self.packages.get_package(node.target.package);
        let source_files = cond_comp::filter_files(
            &pkg.raw,
            &pkg.root_path,
            pkg.source_files.iter().map(|x| x.as_path()),
            &CompileCondition {
                optlevel: self.build_env.opt_level,
                test_kind: node.target.kind.into(),
                backend: self.build_env.target_backend,
            },
        )
        .map_err(|err| BuildPlanConstructError::ParseCondExprError { node, err })?;
        Ok(source_files)
    }

    fn build_build_c_stubs(&mut self, node: BuildPlanNode) -> Result<(), BuildPlanConstructError> {
        // Depends on nothing, but anyway needs to be inserted into the graph.
        let self_id = self.need_node(node);

        // Resolve the C stub files
        let pkg = self.packages.get_package(node.target.package);
        let c_source = pkg.c_stub_files.clone();
        self.resolved_node(self_id, BuildActionSpec::BuildC(c_source));

        Ok(())
    }

    /// Performs the construction of two actions in consecutive: Make Executable
    /// and Link Core.
    ///
    /// The two actions are always created together (Link Core is always a
    /// direct dependency of Make Executable, and there's no other actions that
    /// depends on Link Core), and both actions require traversing through the
    /// list of dependencies, so it's better to create both nodes at once,
    /// instead of in separate functions.
    fn build_make_exec_link_core(
        &mut self,
        make_exec_node: BuildPlanNode,
    ) -> Result<(), BuildPlanConstructError> {
        /*
            Link-core requires traversing all output of the current package's
            all transitive dependencies, and emitting them in DFS post-order.

            There are a couple of replacements needed to be done when the
            traversal completes:
            - Whitebox tests need to replace the normal package in the
                dependency graph (at the same position as the normal package).
                This is technically a circular dependency but anyway :)
            - Virtual package overrides need to replace their overridden
                packages in the dependency graph. This is done by not adding
                virtual packages at all when collecting the targets.
                TODO: virtual packages are not yet implemented here.
        */

        // This DFS is shared by both LinkCore and MakeExecutable actions.
        let mut dfs = DfsPostOrder::new(&self.build_deps.dep_graph, make_exec_node.target);
        // This is the link core sources
        let mut link_core_deps = IndexSet::new();
        // This is the C stub sources
        let mut c_stub_deps = Vec::new();
        // DFS itself
        while let Some(next) = dfs.next(&self.build_deps.dep_graph) {
            if next.kind == TargetKind::WhiteboxTest {
                // Replace whitebox tests, if any
                let source_target = next.package.build_target(TargetKind::Source);
                if let Some(source_idx) = link_core_deps.get_index_of(&source_target) {
                    let source_mut = link_core_deps
                        .get_index_mut2(source_idx)
                        .expect("Source index is valid");
                    *source_mut = next;
                    continue;
                } else {
                    // No source target found, resort to regular path
                }
            }

            // Regular package
            link_core_deps.insert(next);
            // If there's any C stubs, add it (native only)
            let pkg = self.packages.get_package(next.package);
            if self.build_env.target_backend.is_native() && !pkg.c_stub_files.is_empty() {
                c_stub_deps.push(next);
            }
        }

        let link_core_node = BuildPlanNode {
            target: make_exec_node.target,
            action: TargetAction::LinkCore,
        };

        // Add edges to all dependencies
        // Note that we have already replaced unnecessary dependencies
        let link_core_id = self.need_node(link_core_node);
        for target in &link_core_deps {
            let dep_node = BuildPlanNode {
                target: *target,
                action: TargetAction::Build,
            };
            let dep_id = self.need_node(dep_node);
            self.add_edge(link_core_id, dep_id);
        }

        let targets = link_core_deps.into_iter().collect();
        let spec = BuildActionSpec::LinkCore(targets);
        self.resolved_node(link_core_id, spec);

        // Add edge from make exec to link core
        let make_exec_id = self.need_node(make_exec_node);
        self.add_edge(make_exec_id, link_core_id);

        // Add dependencies of make exec
        for target in &c_stub_deps {
            let dep_node = BuildPlanNode {
                target: *target,
                action: TargetAction::BuildCStubs,
            };
            let dep_id = self.need_node(dep_node);
            self.add_edge(make_exec_id, dep_id);
        }
        self.resolved_node(make_exec_id, BuildActionSpec::MakeExecutable(c_stub_deps));

        Ok(())
    }
}
