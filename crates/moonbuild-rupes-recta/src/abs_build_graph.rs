//! Constructs the abstract build graph from the given build conditions.
//!
//! This module handles a different thing from the package dependency graph
//! generated by [`crate::solve`]. `solve` mainly constructs a dependency graph
//! that is not affected by what we're actually building, nor does it cares
//! about what actions are actually carried out on the dependency graph (like
//! check, build or test).
//!
//! In contrast, this module generates the actual build graph from a list of
//! input action nodes. Irrelevant packages are not included in this graph,
//! nor does irrelevant actions.
//!
//! That's said, there's a reason why the graph is called an abstract build
//! graph, instead of just a "build graph". Although nodes in this graph
//! represents concrete actions done, they are not the actual command and args
//! passed to subprocesses -- which need another lowering just before running
//! the build graph.

use std::{collections::HashMap, path::PathBuf};

use indexmap::IndexSet;
use petgraph::{
    csr::{DefaultIx, IndexType},
    graph::{DiGraph, NodeIndex},
    prelude::DiGraphMap,
};

use crate::{
    discover::DiscoverResult,
    model::{BuildTarget, TargetAction},
    solve::DepRelationship,
};

/// The ID of a build graph node.
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, Default)]
struct BuildNodeIx(DefaultIx);

unsafe impl IndexType for BuildNodeIx {
    fn new(x: usize) -> Self {
        Self(<DefaultIx as IndexType>::new(x))
    }

    fn index(&self) -> usize {
        self.0.index()
    }

    fn max() -> Self {
        Self(<DefaultIx as IndexType>::max())
    }
}

pub type BuildNodeId = NodeIndex<BuildNodeIx>;

type BuildActionGraph = DiGraph<BuildActionSpec, (), BuildNodeIx>;

/// A directed graph representation of build dependencies and targets.
///
/// `AbstractBuildGraph` maintains a directed graph where nodes represent build
/// components and edges represent dependencies between them. It also stores
/// specifications for each build target, mapping targets to their detailed
/// configuration and requirements.
#[derive(Default)]
pub struct AbstractBuildGraph {
    graph: BuildActionGraph,
    target_map: HashMap<BuildGraphNode, BuildNodeId>,
}

impl AbstractBuildGraph {
    pub fn get_id_from_node(&self, node: BuildGraphNode) -> Option<BuildNodeId> {
        self.target_map.get(&node).copied()
    }
}

/// A node in the build dependency graph, containing a build target and the
/// corresponding action that should be performed on that target.
#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub struct BuildGraphNode {
    pub target: BuildTarget,
    pub action: TargetAction,
}

/// The specification of the specific build target, e.g. its files.
pub enum BuildActionSpec {
    Check,
    /// Build the given list of MoonBit source files.
    BuildMbt(Vec<PathBuf>),
    /// Build the given list of C source files.
    BuildC(Vec<PathBuf>),
    /// Link the core files from the given list of nodes, **in order**.
    LinkCore(Vec<BuildGraphNode>),
    MakeExecutable,
    GenerateMbti,

    /// A placeholder for pending nodes that are not yet resolved.
    #[doc(hidden)]
    Pending,
}

/// Represents errors that may occur during build graph construction.
///
/// TODO: Will we even meet errors during build graph construction?
pub enum BuildGraphConstructError {}

/// Construct an abstract build graph from the given packages and input actions.
pub fn build_graph(
    packages: &DiscoverResult,
    build_deps: &DepRelationship,
    input: &[BuildGraphNode],
) -> Result<AbstractBuildGraph, BuildGraphConstructError> {
    let mut constructor = BuildGraphConstructor::new(packages, build_deps);
    constructor.build(input)?;
    Ok(constructor.finish())
}

struct BuildGraphConstructor<'a> {
    packages: &'a DiscoverResult,
    build_deps: &'a DepRelationship,
    res: AbstractBuildGraph,
    pending: Vec<BuildGraphNode>,
}

impl<'a> BuildGraphConstructor<'a> {
    fn new(packages: &'a DiscoverResult, build_deps: &'a DepRelationship) -> Self {
        Self {
            packages,
            build_deps,
            res: AbstractBuildGraph::default(),
            pending: Vec::new(),
        }
    }

    fn finish(self) -> AbstractBuildGraph {
        self.res
    }

    fn build(&mut self, input: &[BuildGraphNode]) -> Result<(), BuildGraphConstructError> {
        assert!(
            self.pending.is_empty(),
            "Pending nodes should be empty before starting the build"
        );
        self.pending.extend_from_slice(input);
        while let Some(node) = self.pending.pop() {
            self.build_action_dependencies(node);
        }
        Ok(())
    }

    /// Tell the build graph that we need to calculate the graph portion of a
    /// new node. To deduplicate pending nodes, this should be called before
    /// adding relevant edges to the graph (since the latter will also add the
    /// node into the graph).
    fn added_node(&mut self, node: BuildGraphNode) -> BuildNodeId {
        if let Some(node_id) = self.res.target_map.get(&node) {
            *node_id
        } else {
            self.pending.push(node);
            let node_id = self.res.graph.add_node(BuildActionSpec::Pending);
            node_id
        }
    }

    /// Calculate the build action's dependencies and insert relevant edges to the
    /// build action graph.
    fn build_action_dependencies(&mut self, node: BuildGraphNode) {
        match node.action {
            TargetAction::Check => {
                // Check depends on `.mi` of all dependencies, which practically
                // means the Check of all dependencies.
                for dep in self
                    .build_deps
                    .dep_graph
                    .neighbors_directed(node.target, petgraph::Direction::Incoming)
                {
                    let dep_node = BuildGraphNode {
                        target: dep,
                        action: TargetAction::Check,
                    };
                    let dep_node = self.added_node(dep_node);
                    let node = self.added_node(node);
                    self.res.graph.add_edge(node, dep_node, ());
                }
            }

            TargetAction::Build => {
                // Build depends on `.mi`` of all dependencies. Although Check can
                // also emit `.mi` files, since we're building, this action actually
                // means we need to build all dependencies.
                for dep in self
                    .build_deps
                    .dep_graph
                    .neighbors_directed(node.target, petgraph::Direction::Incoming)
                {
                    let dep_node = BuildGraphNode {
                        target: dep,
                        action: TargetAction::Build,
                    };
                    let dep_node = self.added_node(dep_node);
                    let node = self.added_node(node);
                    self.res.graph.add_edge(node, dep_node, ());
                }
            }

            TargetAction::BuildCStubs => {
                // Depends on nothing, but anyway needs to be inserted into the
                // graph.
                self.added_node(node);
            }

            TargetAction::LinkCore => {
                // LinkCore depends on all the compilation outputs of the package's
                // dependency,
                todo!()
            }

            TargetAction::MakeExecutable => {
                todo!()
            }
        }
    }
}
